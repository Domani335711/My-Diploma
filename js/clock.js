// timer - счетчик акций 108
// Будет много переменных: время окончания; дня, минуты, секунды, милисекунды (если надо). Чтобы посчитать, сколько осталось времени, нужна еще одна переменная t (от нынешнего времени отнять время окончания)
    // const timeEnd = "2022-12-25 15:20:10:15"; // время, когда должен закончиться таймер. Если не надо время, можно его не указывать. Как только наступит дата, таймер обнулиться. Отсчет времени в милисекундах, поэтому применяются формулы
    // let t = new Date();
    // console.log(t);
    const timeEnd = "2023-08-31"; //когда акция должна закончиться. Хватать сейчас год, дату не надо. Сделаем позже. Все время в JS считается в милисекундах
    
    function getTimeRemaning(endtime){ // 110 
          // сюда будем переносить, когда таймер должен закончиться. Напишем алгоритм для высчитывания акций. У каждого товара свое время окончания акции
        const t = Date.parse(endtime) - Date.parse (new Date()), //  время окончания акции минус нынешнее=сколько осталось в милисекундах. отсчитываем от конечной даты нынешнюю и узнаем, сколько осталось. Используем метод parse (работает только со временем - переводит date (текст) в число (милисекунды), т.к. не можем текст отнять от текста). делаем высчитывание от нынешнего времени, когда таймер должен закончиться. Создадим переменные в функциях, чтобы они не работали за пределами этих функциях
                days = Math.floor(t/(1000*60*60*24)), // Надо, чтобы все округлялось, т.к. не м.б., например, 2,5 дня, а остаток должен куда-то уходить. Когда первым пишем Math или Date, вызывается какой-то метод, у которого есть какие-то функции (н., floor - округление). В оставшемся времени до конца акции превращаем милисекунды в дни. Берем переменную t, которая посчитает все и делим на формулу (есть в интернете перевод)
                hours = Math.floor((t/(1000*60*60))%24), //% - это остаток от числа. Убираем остаток вниз
                minutes = Math.floor((t/(1000*60))%60), 
                seconds = Math.floor((t/1000)%60), // остаток уже никуда не девается - он не нужен - его не учитываем
        return{ // чтобы могли взять вычисления, надо к переменным добавить ключевые слова, по которым будем обращаться, т.е. будем обращаться не к самой переменной, а к ключевому слову (total, days и т.д.), которым она будет обозначена
            'total':t,
            'days':days,
            'hours':hours,
            'minutes':minutes,
            'seconds':seconds // не надо ставить ни , ни ; т.к. если ничего не ставить, то понимает, что это конечное значение
        }
    } // 124

    function setClock(selector,endtime){ // 126 создадим функцию, в которую вложим все значения (дни, часы, минуты и т.д.). В них будем вкладывать те значения, которые посчитаются в предыдущей функции getTimeRemaining. Selector - название блока, с которым будем работать, в котором находится весь таймер. Названия аргументов у разных функций не персекаются
        const timer = document.querySelector(selector),
            days = timer.querySelector('#days'), // 128  заходит в весь проект и находит всего 1 таймер (1 div с классом days). Но, если таймеров (счетчиков акций) много, то необходимо создавать этот атрибут selector и вписывать сюда определенный класс, т.к. у всех таймеров название идентификаторов days, hours, minutes, seconds будет везде одинаковое, но только таймеры могут называться по-другому. Тогда укажем, что не весь документ (вместо document), а зайди в переменную timer и посмотри, какой ты класс схватил. Т.е., если схватить именно класс div с классом timer, то только в нем он будет искать все идентификаторы и классы, которые укажем ниже. При этом мы указываем, не название document, а название переменной timer (или какой-то другой переменной, название которой ищем в коде в браузере). А, если напишем timer, то будет брать первый попавшийся таймер, который увидит
            hours = timer.querySelector('#hours'),
            minutes = timer.querySelector('#minutes'),
            seconds = timer.querySelector('#seconds');
            timeInterval = setInterval (updateСlock,1000); // 132  когда акция заканчивается, в таймере будет: 00:00:00:00. Таймер должен самостоятельно обновляться каждую секунду, а не мы должны обновлять страницу. Поэтому создадим переменную timeInterval (изменение интервала времени). Чтобы изменялся таймер по времени - используем setInterval. здесь задается функция (назовем ее updateСlock. Функцию можно вызвать до ее создания). Это позволит изменять в блоках таймера числа и надо указать, через какой промежуток времени эти изменения будут происходить (задаем не в милисекундах (1), а в секундах (1000)). Функцию updateСlock не можем создавать до ее задания, т.к. потом ее будет сложно вызвать, поэтому зададим ее в функции setClock:
       
        function updateСlock(){
            const t = getTimeRemaning(endtime) // должны брать значения от getTimeRemaining и вставлять их в блок выше (в дни, часы, минуты...). Но, чтобы обратиться к этой функции (т.е. выйти за ее пределы и зайти в верхнюю), надо создать переменную (отправную точку). Т.е. через переменную t будем обращаться к функции getTimeRemaining и хватать переменные, который написаны выше в блоке return (t, days,hours...), но будем их хватать через ключевые слова (total, days...), т.к. напрямую нельзя
            days.innerHTML = t.days; // для того, чтобы поменять что-то в переменной используем innerHTML или textContent. Сначала поменяем days: заходим в переменную days и укажем, что хотим поменять: из фенкции getTimeRemaining возьмем ключевое слово days. Для этого берем переменную t, т.к. в ней лежит вся функция, и вызываем то, что необходимо: ключевое слово days (при вызове '' ставить уже не надо). Дальше часы...
            hours.innerHTML = t.hours;
            minutes.innerHTML = t.minutes;
            seconds.innerHTML = t.seconds;
            if(t.total <=0){ // когда все значения дойдут до 0, счетчик должен обнулиться и остановиться. Но, когда доходят до 0, блок просто исчезает. И, чтобы он смог исчезнуть, надо написать условие: если функции t в ключевое слово total (высчитывает от конечного текущее) будет<=0, то используем метод обнуления clearInterval. В аттрибут указываем timeInterval
                clearInterval(timeInterval);
            days.innerHTML = '00'; // чтобы остались все 00, надо вместо переменных написать 00 в '' (как текст)
            hours.innerHTML = '00'; // можно написать и без '' как число, но тогда надо писать 0, а не 00, т.к. числа 00 нет
            minutes.innerHTML = '00';
            seconds.innerHTML = '00';
            }
            // 
        }
    } // 147
// теперь надо вызвать функцию setClock. В параметр selector надо написать класс, в котором лежит весь таймер, а вместо параметра endtime должны написать переменную timeEnd (т.е., когда закончится весь таймер) 
    setClock('.timer',timeEnd); // 150 // Весь таймер лежит в классе timer (видим это в коде в браузере). теперь надо вызвать функцию setClock. В параметр selector надо написать класс, в котором лежит весь таймер, а вместо параметра endtime должны написать переменную timeEnd (т.е., когда закончится весь таймер) 